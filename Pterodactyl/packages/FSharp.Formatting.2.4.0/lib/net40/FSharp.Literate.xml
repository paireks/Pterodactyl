<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Literate</name></assembly>
<members>
<member name="">

</member>
<member name="T:FSharp.Collections.Tree`1">
<summary>
 Represents a tree with nodes containing values an a list of children
</summary>
</member>
<member name="M:FSharp.Collections.Tree.ofIndentedList``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
 Turns a list of items with an indentation specified by an integer
 into a tree where indented items are children.
</summary>
</member>
<member name="M:FSharp.Collections.Tree.takeDeeperThan``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Takes elements that are deeper (children) and turns them into nodes
</summary>
</member>
<member name="M:FSharp.Collections.Tree.takeAtLevel``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Takes all elements at the specified level and turns them into nodes
</summary>
</member>
<member name="T:FSharp.Collections.Tree">

</member>
<member name="M:FSharp.Collections.List.nestUnderLastMatching``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 A function that nests items of the input sequence 
 that do not match a specified predicate under the 
 last item that matches the predicate. 
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionUntilEquals``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions the input list into two parts - the break is added 
 at a point where the list starts with the specified sub-list.
</summary>
</member>
<member name="M:FSharp.Collections.List.startsWith``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Tests whether a list starts with the elements of another
 list (specified as the first parameter)
</summary>
</member>
<member name="M:FSharp.Collections.List.iterInterleaved``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Iterates over the elements of the list and calls the first function for 
 every element. Between each two elements, the second function is called.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionUntil``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the 
 specified predicate returns &apos;false&apos;) and a rest of the list.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionWhileLookahead``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the specified predicate 
 returns true) and a rest of the list. The predicate gets the entire 
 tail of the list and can perform lookahead.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the 
 specified predicate returns true) and a rest of the list.
</summary>
</member>
<member name="M:FSharp.Collections.List.skipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Skips elements while the predicate returns &apos;true&apos; and then 
 returns the rest of the list as a result.
</summary>
</member>
<member name="M:FSharp.Collections.List.skip``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Skips the specified number of elements. Fails if the list is smaller.
</summary>
</member>
<member name="M:FSharp.Collections.List.singleton``1(``0)">
<summary>
 Returns a singleton list containing a specified value
</summary>
</member>
<member name="T:FSharp.Collections.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Literate.CompilerContext">
<summary>
 Specifies a context that is passed to functions 
 that need to use the F# compiler
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Literate.FsiEvaluationResult">
<summary>
 Represents the result of evaluating an F# snippet. This contains
 the generated console output together with a result and its static type.
</summary>
</member>
<member name="F:FSharp.Literate.FSharp.Literate.FsiEvaluator.valueTransformations">
<summary>
 Registered transformations for pretty printing values
 (the default formats value as a string and emits single CodeBlock)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Literate.FsiEvaluator.RegisterTransformation(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Object,System.Type},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Markdown.MarkdownParagraph}}})">
<summary>
 Register a function that formats (some) values that are produced by the evaluator.
 The specified function should return &apos;Some&apos; when it knows how to format a value
 and it should return formatted 
</summary>
</member>
<member name="M:FSharp.Literate.FsiEvaluator.FormatValue``1(``0,System.Type)">
<summary>
 Format a specified value and produce a markdown document as the result
</summary>
</member>
<member name="M:FSharp.Literate.FsiEvaluator.FormatOutput(System.String)">
<summary>
 Format a specified output (produces Markdown code block at the moment)
</summary>
</member>
<member name="M:FSharp.Literate.FsiEvaluator.Evaluate(System.String,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Evaluates the given text in an fsi session and returns
 an FsiEvaluationResult.

 If evaluated as an expression, Result should be set with the
 result of evaluating the text as an F# expression.
 If not, just the console output of the evaluation is captured and
 returned in Output.

 If file is set, the text will be evaluated as if it was present in the
 given script file - this is for correct usage of #I and #r with relative paths.
 Note however that __SOURCE_DIRECTORY___ does not currently pick this up.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Literate.FsiEvaluator">
<summary>
 A wrapper for F# interactive serivice that is used to evaluate inline snippets
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Literate.Literate.ProcessScriptFile(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.OutputKind},Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.FsiEvaluator},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Process F# Script file
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ProcessMarkdown(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.OutputKind},Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Process Markdown document
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ProcessDirectory(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.OutputKind},Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.FsiEvaluator},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Process directory containing a mix of Markdown documents and F# Script files
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ParseScriptString``1(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.FsiEvaluator})">
<summary>
 Parse F# Script file
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ParseScriptFile``1(System.String,Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.FsiEvaluator})">
<summary>
 Parse F# Script file
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ParseMarkdownString``1(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.FsiEvaluator})">
<summary>
 Parse Markdown document
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ParseMarkdownFile``1(System.String,Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.FsiEvaluator})">
<summary>
 Parse Markdown document
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Literate.Literate">
<summary>
 This type provides three simple methods for calling the literate programming tool.
 The `ProcessMarkdown` and `ProcessScriptFile` methods process a single Markdown document
 and F# script, respectively. The `ProcessDirectory` method handles an entire directory tree
 (ooking for `*.fsx` and `*.md` files).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.Literate.LiterateDocument.SourceFile">
<summary>
 Location where the file was loaded from
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.Source">
<summary>
 Original document source code
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.Paragraphs">
<summary>
 Returns a list of paragraphs in the document
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.MarkdownDocument">
<summary>
 Return as markdown document, throwing away additional stuff
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.FormattedTips">
<summary>
 Formatted tool tips
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.Errors">
<summary>
 Errors
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.DefinedLinks">
<summary>
 Returns a dictionary containing explicitly defined links
</summary>
</member>
<member name="M:FSharp.Literate.LiterateDocument.With(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Markdown.MarkdownParagraph}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IDictionary{System.String,System.Tuple{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}}},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.LiterateSource},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{FSharp.CodeFormat.SourceError}})">
<summary>
 Clone the document and change some of its properties
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Literate.LiterateDocument">
<summary>
 Representation of a literate document - the representation of Paragraphs
 uses an F# discriminated union type and so is best used from F#.
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.LanguageTaggedCode">
<summary>
 Ordinary formatted code snippet in non-F# language (tagged with language code)
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.FormattedCode">
<summary>
 Ordinary formatted code snippet
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.OutputReferencedCode">
<summary>
 (*** define-output:foo ***) - Code snippet that is not visible, but whose output
 is used somewehre else in the literate doc via (*** include-output:foo ***)
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.HiddenCode">
<summary>
 (*** hide ***) or (*** define:foo ***) - Code snippet that is not visible in 
 the output (but is needed for type checking, evaluation, or to be included later)
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.ValueReference">
<summary>
 (*** include-value:foo ***) - Include the formatting of a specified value here
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.OutputReference">
<summary>
 (*** include-output:foo ***) - Include output from a snippet here 
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.CodeReference">
<summary>
 (*** include:foo ***) - Include formatted snippet from other part of the document here 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Literate.OutputKind">
<summary>
 Defines the two possible output types from literate script: HTML and LaTeX.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Literate.ProcessingContext">
<summary>
 Specifies a context that is passed to functions that generate the output
</summary>
</member>
<member name="">

</member>
<member name="F:FSharp.Literate.FSharp.Literate.RazorRender.ViewBag@">
<summary>
 Dynamic object with more properties (?)
</summary>
</member>
<member name="F:FSharp.Literate.FSharp.Literate.RazorRender.Model@">
<summary>
 Model - whatever the user specifies for the page
</summary>
</member>
<member name="F:FSharp.Literate.FSharp.Literate.RazorRender.Resolver@">
<summary>
 Global resolver (for use in &apos;DocPageTempalateBase&apos;)
</summary>
</member>
<member name="P:FSharp.Literate.RazorRender.ViewBag(RazorEngine.Templating.DynamicViewBag)">
<summary>
 Dynamic object with more properties (?)
</summary>
</member>
<member name="P:FSharp.Literate.RazorRender.Resolver(RazorEngine.Templating.ITemplateResolver)">
<summary>
 Global resolver (for use in &apos;DocPageTempalateBase&apos;)
</summary>
</member>
<member name="P:FSharp.Literate.RazorRender.Model(System.Object)">
<summary>
 Model - whatever the user specifies for the page
</summary>
</member>
<member name="P:FSharp.Literate.RazorRender.ViewBag">
<summary>
 Dynamic object with more properties (?)
</summary>
</member>
<member name="P:FSharp.Literate.RazorRender.Resolver">
<summary>
 Global resolver (for use in &apos;DocPageTempalateBase&apos;)
</summary>
</member>
<member name="P:FSharp.Literate.RazorRender.Model">
<summary>
 Model - whatever the user specifies for the page
</summary>
</member>
<member name="M:FSharp.Literate.RazorRender.Resolve(System.Collections.Generic.IEnumerable{System.String},System.String)">
<summary>
 Find file in one of the specified layout roots
</summary>
</member>
<member name="M:FSharp.Literate.RazorRender.ProcessFile``1(System.String,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,``0}}})">
<summary>
 Process source file and return result as a string
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.Literate.StringDictionary.Item(System.String)">
<summary>
 Report more useful errors when key not found (.NET dictionary does not do this...)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.Literate.CodeBlockUtils.parseScriptFile">
<summary>
 Parse F# script file into a sequence of snippets, comments and commands
</summary>
</member>
<member name="M:FSharp.Literate.CodeBlockUtils.collectSnippet(Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line},Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line})">
<summary>
 Collecting a block of F# snippet
</summary>
</member>
<member name="M:FSharp.Literate.CodeBlockUtils.collectComment(System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line})">
<summary>
 Waiting for the end of a comment      
</summary>
</member>
<member name="M:FSharp.Literate.CodeBlockUtils.|ConcatenatedComments|_|(FSharp.CodeFormat.Line)">
<summary>
 Succeeds when a line (list of tokens) contains only Comment 
 tokens and returns the text from the comment as a string
 (Comment may also be followed by Whitespace that is skipped)
</summary>
</member>
<member name="M:FSharp.Literate.CodeBlockUtils.trimBlanksAndReverse(System.Collections.Generic.IEnumerable{FSharp.CodeFormat.Line})">
<summary>
 Trim blank lines from both ends of a lines list &amp; reverse it (we accumulate 
 lines &amp; we want to remove all blanks before returning BlockSnippet)
</summary>
</member>
<member name="T:FSharp.Literate.CodeBlockUtils">
<summary>
 Parsing of F# Script files with Markdown commands. Given a parsed script file, we 
 split it into a sequence of comments, snippets and commands (comment starts with 
 `(**` and ending with `*)` are translated to Markdown, snippet is all other F# code 
 and command looks like `(*** key1:value, key2:value ***)` (and should be single line).
</summary>
</member>
<member name="M:FSharp.Literate.Formatting.getSourceDocument(FSharp.Literate.LiterateDocument)">
<summary>
 Given literate document, get a new MarkdownDocument that represents the 
 entire source code of the specified document (with possible `fsx` formatting)
</summary>
</member>
<member name="M:FSharp.Literate.Formatting.findHeadings(System.Collections.Generic.IEnumerable{FSharp.Markdown.MarkdownParagraph},FSharp.Literate.OutputKind)">
<summary>
 Try find first-level heading in the paragraph collection
</summary>
</member>
<member name="M:FSharp.Literate.Formatting.format(FSharp.Markdown.MarkdownDocument,FSharp.Literate.OutputKind)">
<summary>
 Format document with the specified output kind
</summary>
</member>
<member name="T:FSharp.Literate.Formatting">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Literate.Log.run(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Run the specified I/O interaction in the synchronized log
</summary>
</member>
<member name="M:FSharp.Literate.Log.logf``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Printf function that prints to a synchronized log
</summary>
</member>
<member name="M:FSharp.Literate.Log.colored(System.ConsoleColor)">
<summary>
 Can be used to change the console color in a current scope
 (The result is `IDisposable` and can be bound using `use`)
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Literate.Log">

</member>
<member name="">

</member>
<member name="T:FSharp.Literate.Matching">

</member>
<member name="M:FSharp.Literate.Parallel.pfor``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Threading.Tasks.ParallelLoopState,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}})">
<summary>
 Parallel for loop with local state
</summary>
</member>
<member name="T:FSharp.Literate.Parallel">

</member>
<member name="M:FSharp.Literate.ParseMarkdown.parseMarkdown(System.String,System.String)">
<summary>
 Parse the specified Markdown document and return it
 as `LiterateDocument` (without processing code snippets)
</summary>
</member>
<member name="T:FSharp.Literate.ParseMarkdown">

</member>
<member name="M:FSharp.Literate.ParseScript.parseScriptFile(System.String,System.String,FSharp.Literate.CompilerContext)">
<summary>
 Parse script file with specified name and content
 and return `LiterateDocument` with the content
</summary>
</member>
<member name="M:FSharp.Literate.ParseScript.transformBlocks(Microsoft.FSharp.Collections.FSharpList{FSharp.Markdown.MarkdownParagraph},Microsoft.FSharp.Collections.FSharpList{System.Collections.Generic.IDictionary{System.String,System.Tuple{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}}},Microsoft.FSharp.Collections.FSharpList{FSharp.Literate.CodeBlockUtils.Block})">
<summary>
 Transform list of code blocks (snippet/comment/command)
 into a formatted Markdown document, with link definitions
</summary>
</member>
<member name="T:FSharp.Literate.ParseScript">
<summary>
 Turns the content of `fsx` file into `LiterateDocument` that contains
 formatted F# snippets and parsed Markdown document. Handles commands such
 as `hide`, `define` and `include`.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.Literate.Templating.generateFile(System.String,System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.String}},Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Depending on the template file, use either Razor engine
 or simple Html engine with {replacements} to format the document
</summary>
</member>
<member name="M:FSharp.Literate.Templating.replaceParameters(System.String,System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.String}},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Replace {parameter} in the input string with 
 values defined in the specified list
</summary>
</member>
<member name="T:FSharp.Literate.Templating">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Literate.Transformations.EvalKey">
<summary>
 Represents key in a dictionary with evaluation results
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.replaceLiterateParagraphs(FSharp.Literate.ProcessingContext,FSharp.Literate.LiterateDocument)">
<summary>
 Replace all special &apos;LiterateParagraph&apos; elements with ordinary HTML/Latex
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.replaceSpecialCodes(FSharp.Literate.ProcessingContext,System.Collections.Generic.IDictionary{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line},System.String},FSharp.Markdown.MarkdownParagraph},FSharp.Markdown.MarkdownParagraph)">
<summary>
 Replace all special &apos;LiterateParagraph&apos; elements recursively using the given lookup dictionary
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.collectCodes(FSharp.Markdown.MarkdownParagraph)">
<summary>
 Collect all code snippets in the document (so that we can format all of them)
 The resulting dictionary has Choice as the key, so that we can distinguish 
 between moved snippets and ordinary snippets
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.evaluateCodeSnippets(FSharp.Literate.CompilerContext,FSharp.Literate.LiterateDocument)">
<summary>
 Transform the specified literate document &amp; evaluate all F# snippets
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.Literate.Transformations.evalAllSnippets(FSharp.Literate.FsiEvaluator,FSharp.Literate.LiterateDocument)">
<summary>
 Given an evaluator and document, evaluate all code snippets and return a map with
 their results - the key is `ValueRef(name)` for all value references and 
 `OutputRef(name)` for all references to the snippet console output
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.evalBlocks(FSharp.Literate.FsiEvaluator,System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Literate.Transformations.EvalKey,FSharp.Literate.FsiEvaluationResult}},Microsoft.FSharp.Collections.FSharpList{FSharp.Markdown.MarkdownParagraph})">
<summary>
 Evaluate all the snippets in a literate document, returning the results.
 The result is a map of string * bool to FsiEvaluationResult. The bool indicates
 whether the result is a top level variable (i.e. include-value) or a reference to 
 some output (i.e. define-output and include-output). This just to put each of those
 names in a separate scope.
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.unparse(Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line})">
<summary>
 Unparse a Line list to a string - for evaluation by fsi.
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.generateReferences(FSharp.Literate.LiterateDocument)">
<summary>
 Turn all indirect links into a references 
 and add paragraph to the document
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.generateRefParagraphs``1(System.Collections.Generic.IDictionary{``0,System.Tuple{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Given all links defined in the Markdown document and a list of all links
 that are accessed somewhere from the document, generate References paragraph
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.replaceReferences(System.Collections.Generic.IDictionary{System.String,System.Int32})">
<summary>
 Given Markdown document, add a number using the given index to all indirect 
 references. For example, [article][ref] becomes [article][ref] [1](#rfxyz)
</summary>
</member>
<member name="P:FSharp.Literate.Transformations.collectReferences">
<summary>
 Given Markdown document, get the keys of all IndirectLinks 
 (to be used when generating paragraph with all references)
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.formatCodeSnippets(System.String,FSharp.Literate.CompilerContext,FSharp.Literate.LiterateDocument)">
<summary>
 Walk over literate document and replace F# code snippets with 
 their formatted representation (of `LiterateParagraph` type)
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.replaceCodeSnippets(System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line}},FSharp.Markdown.MarkdownParagraph)">
<summary>
 Replace CodeBlock elements with formatted HTML that was processed by the F# snippets tool
 (The dictionary argument is a map from original code snippets to formatted HTML snippets.)
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.collectCodeSnippets(FSharp.Markdown.MarkdownParagraph)">
<summary>
 Iterate over Markdown document and extract all F# code snippets that we want
 to colorize. We skip snippets that specify non-fsharp langauge e.g. [lang=csharp].
</summary>
</member>
<member name="T:FSharp.Literate.Transformations">

</member>
<member name="M:FSharp.Patterns.|Command|_|``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Lookup in a dictionary
</summary>
</member>
<member name="M:FSharp.Patterns.|ParseCommand|_|(System.String)">
<summary>
 Utility for parsing commands - this deals with a single command.
</summary>
</member>
<member name="M:FSharp.Patterns.|ParseCommands|_|(System.String)">
<summary>
 Utility for parsing commands. Commands can be used in different places. We 
 recognize `key1=value, key2=value` and also `key1:value, key2:value`
</summary>
</member>
<member name="M:FSharp.Patterns.|Let|``2(``0,``1)">
<summary>
 Parameterized pattern that assigns the specified value to the 
 first component of a tuple. Usage:

    match str with
    | Let 1 (n, &quot;one&quot;) | Let 2 (n, &quot;two&quot;) -&gt; n
 
</summary>
</member>
<member name="P:FSharp.Patterns.Lines.|TrimBlankStart|">
<summary>
 Removes whitespace lines from the beginning of the list
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TakeStartingWithOrBlank|_|(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Matches when there are some lines at the beginning that are 
 either empty (or whitespace) or start with the specified string.
 Returns all such lines from the beginning until a different line.
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TrimBlank|(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Removes blank lines from the start and the end of a list
</summary>
</member>
<member name="T:FSharp.Patterns.Lines">

</member>
<member name="M:FSharp.Patterns.List.|AsString|(Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Retruns a list of characters as a string.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|BracketDelimited|_|(System.Char,System.Char,Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Matches a list if it starts with a bracketed list. Nested brackets
 are skipped (by counting opening and closing brackets) and can be 
 escaped using the &apos;\&apos; symbol.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|Delimited|_|``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Matches a list if it starts with a sub-list that is delimited
 using the specified delimiter. Returns a wrapped list and the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|DelimitedWith|_|``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Matches a list if it starts with a sub-list that is delimited
 using the specified delimiters. Returns a wrapped list and the rest.
</summary>
</member>
<member name="T:FSharp.Patterns.List">

</member>
<member name="M:FSharp.Patterns.String.removeSpaces(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Given a list of lines indented with certan number of whitespace 
 characters (spaces), remove the spaces from the beginning of each line 
 and return the string as a list of lines
</summary>
</member>
<member name="M:FSharp.Patterns.String.|EqualsRepeated|_|(System.String,System.String)">
<summary>
 Matches when a string consists of some number of 
 complete repetitions of a specified sub-string.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithWrapped|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with a sub-string wrapped using the 
 opening and closing sub-string specified in the parameter.
 For example &quot;[aa]bc&quot; is wrapped in [ and ] pair. Returns the wrapped
 text together with the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithRepeated|_|(System.String,System.String)">
<summary>
 Matches when a string starts with a non-zero number of complete
 repetitions of the specified parameter (and returns the number
 of repetitions, together with the rest of the string)

    let (StartsWithRepeated &quot;/\&quot; (2, &quot; abc&quot;)) = &quot;/\/\ abc&quot;

</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsAndEndsWithTrim|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with the given value and ends 
 with a given value (and returns trimmed body)
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsAndEndsWith|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with the given value and ends 
 with a given value (and returns the rest of it)
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithTrim|_|(System.String,System.String)">
<summary>
 Matches when a string starts with the specified sub-string
 The matched string is trimmed from all whitespace.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWith|_|(System.String,System.String)">
<summary>
 Matches when a string starts with the specified sub-string
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithAny|_|(System.Collections.Generic.IEnumerable{System.String},System.String)">
<summary>
 Matches when a string starts with any of the specified sub-strings
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimStartAndCount|(System.String)">
<summary>
 Returns a string trimmed from the start together with 
 the number of skipped whitespace characters
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimEndUsing|(System.Collections.Generic.IEnumerable{System.Char},System.String)">
<summary>
 Retrusn a string trimmed from the end using characters given as a parameter
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimStart|(System.String)">
<summary>
 Returns a string trimmed from the start
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimEnd|(System.String)">
<summary>
 Returns a string trimmed from the end
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimBoth|(System.String)">
<summary>
 Returns a string trimmed from both start and end
</summary>
</member>
<member name="M:FSharp.Patterns.String.|Unindented|_|(System.String)">
<summary>
 Matches when a string does starts with non-whitespace
</summary>
</member>
<member name="M:FSharp.Patterns.String.|WhiteSpace|_|(System.String)">
<summary>
 Matches when a string is a whitespace or null
</summary>
</member>
<member name="T:FSharp.Patterns.String">

</member>
<member name="T:FSharp.Patterns">

</member>
<member name="">

</member>
<member name="T:System.AssemblyVersionInformation">

</member>
</members>
</doc>
